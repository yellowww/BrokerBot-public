"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlpacaCryptoClient = void 0;
const entityv2_1 = require("./entityv2");
const websocket_1 = require("./websocket");
class AlpacaCryptoClient extends websocket_1.AlpacaWebsocket {
    constructor(options) {
        const url = options.url.replace("https", "wss") + "/v1beta1/crypto";
        const exchanges = Array.isArray(options.exchanges)
            ? options.exchanges.join(",")
            : options.exchanges;
        options.url = `${url}?exchanges=${exchanges}`;
        options.subscriptions = {
            trades: [],
            quotes: [],
            bars: [],
            dailyBars: [],
        };
        super(options);
    }
    subscribeForTrades(trades) {
        this.session.subscriptions.trades.push(...trades);
        this.subscribe({ trades });
    }
    subscribeForQuotes(quotes) {
        this.session.subscriptions.quotes.push(...quotes);
        this.subscribe({ quotes });
    }
    subscribeForBars(bars) {
        this.session.subscriptions.bars.push(...bars);
        this.subscribe({ bars });
    }
    subscribeForDailyBars(dailyBars) {
        this.session.subscriptions.dailyBars.push(...dailyBars);
        this.subscribe({ dailyBars });
    }
    subscribe(symbols) {
        var _a, _b, _c, _d;
        const subMsg = {
            action: "subscribe",
            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
            dailyBars: (_d = symbols.dailyBars) !== null && _d !== void 0 ? _d : [],
        };
        this.conn.send(this.msgpack.encode(subMsg));
    }
    subscribeAll() {
        const { trades, quotes, bars, dailyBars } = this.session.subscriptions;
        if (trades.length > 0 ||
            quotes.length > 0 ||
            bars.length > 0 ||
            dailyBars.length > 0) {
            const msg = {
                action: "subscribe",
                trades,
                quotes,
                bars,
                dailyBars,
            };
            this.conn.send(this.msgpack.encode(msg));
        }
    }
    unsubscribeFromTrades(trades) {
        this.session.subscriptions.trades =
            this.session.subscriptions.trades.filter((trade) => !trades.includes(trade));
        this.unsubscribe({ trades });
    }
    unsubscribeFromQuotes(quotes) {
        this.session.subscriptions.quotes =
            this.session.subscriptions.quotes.filter((quote) => !quotes.includes(quote));
        this.unsubscribe({ quotes });
    }
    unsubscribeFromBars(bars) {
        this.session.subscriptions.bars = this.session.subscriptions.bars.filter((bar) => !bars.includes(bar));
        this.unsubscribe({ bars });
    }
    unsubscriceFromDailyBars(dailyBars) {
        this.session.subscriptions.dailyBars =
            this.session.subscriptions.dailyBars.filter((dailyBar) => !dailyBars.includes(dailyBar));
        this.unsubscribe({ dailyBars });
    }
    unsubscribe(symbols) {
        var _a, _b, _c, _d;
        const unsubMsg = {
            action: "unsubscribe",
            trades: (_a = symbols.trades) !== null && _a !== void 0 ? _a : [],
            quotes: (_b = symbols.quotes) !== null && _b !== void 0 ? _b : [],
            bars: (_c = symbols.bars) !== null && _c !== void 0 ? _c : [],
            dailyBars: (_d = symbols.dailyBars) !== null && _d !== void 0 ? _d : [],
        };
        this.conn.send(this.msgpack.encode(unsubMsg));
    }
    updateSubscriptions(msg) {
        this.session.subscriptions = {
            trades: msg.trades,
            quotes: msg.quotes,
            bars: msg.bars,
            dailyBars: msg.dailyBars,
        };
        this.log(`listening to streams:
        ${JSON.stringify(this.session.subscriptions)}`);
    }
    onCryptoTrade(fn) {
        this.on(websocket_1.EVENT.TRADES, (trade) => fn(trade));
    }
    onCryptoQuote(fn) {
        this.on(websocket_1.EVENT.QUOTES, (quote) => fn(quote));
    }
    onCryptoBar(fn) {
        this.on(websocket_1.EVENT.BARS, (bar) => fn(bar));
    }
    onCryptoDailyBar(fn) {
        this.on(websocket_1.EVENT.DAILY_BARS, (dailyBar) => fn(dailyBar));
    }
    dataHandler(data) {
        data.forEach((element) => {
            if ("T" in element) {
                switch (element.T) {
                    case "t":
                        this.emit(websocket_1.EVENT.TRADES, (0, entityv2_1.AlpacaCryptoTrade)(element));
                        break;
                    case "q":
                        this.emit(websocket_1.EVENT.QUOTES, (0, entityv2_1.AlpacaCryptoQuote)(element));
                        break;
                    case "b":
                        this.emit(websocket_1.EVENT.BARS, (0, entityv2_1.AlpacaCryptoBar)(element));
                        break;
                    case "d":
                        this.emit(websocket_1.EVENT.DAILY_BARS, (0, entityv2_1.AlpacaCryptoBar)(element));
                        break;
                    default:
                        this.emit(websocket_1.EVENT.CLIENT_ERROR, websocket_1.ERROR.UNEXPECTED_MESSAGE);
                }
            }
        });
    }
}
exports.AlpacaCryptoClient = AlpacaCryptoClient;
